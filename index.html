<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visbord Family Dashboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üè†</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #eee;
        }
        
        .tabs {
            display: flex;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 12px 24px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 8px;
            color: #ccc;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tab:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .tab.active {
            background: #e94560;
            color: white;
        }
        
        .content {
            padding: 40px 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        
        .page {
            display: none;
        }
        
        .page.active {
            display: block;
        }
        
        /* Grandma Countdown */
        .countdown-page-title {
            text-align: center;
            font-size: 24px;
            color: #e94560;
            margin-bottom: 30px;
        }

        .grandmas-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        .countdown-card {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px 20px;
            text-align: center;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .countdown-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .countdown-card.ayelet {
            border-color: rgba(233, 69, 96, 0.3);
        }

        .countdown-card.orly {
            border-color: rgba(168, 85, 247, 0.3);
        }

        .countdown-emoji {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .countdown-title {
            font-size: 22px;
            margin-bottom: 6px;
            color: #e94560;
        }

        .countdown-card.orly .countdown-title {
            color: #a855f7;
        }

        .countdown-subtitle {
            font-size: 14px;
            color: #888;
            margin-bottom: 20px;
        }

        .countdown-number {
            font-size: 80px;
            font-weight: bold;
            background: linear-gradient(135deg, #e94560, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
        }

        .countdown-card.orly .countdown-number {
            background: linear-gradient(135deg, #a855f7, #c084fc);
            -webkit-background-clip: text;
            background-clip: text;
        }

        .countdown-label {
            font-size: 18px;
            color: #aaa;
            margin-top: 8px;
        }

        .countdown-date {
            margin-top: 20px;
            font-size: 14px;
            color: #666;
        }

        @media (max-width: 600px) {
            .tabs {
                padding: 8px;
                gap: 6px;
            }
            .tab {
                padding: 10px 14px;
                font-size: 14px;
            }
            .content {
                padding: 20px 12px;
            }
            .countdown-number {
                font-size: 64px;
            }
            .countdown-card {
                padding: 24px 16px;
            }
        }

        @media (max-width: 380px) {
            .tab {
                padding: 8px 10px;
                font-size: 13px;
            }
        }

        /* Markdown TODOs styling */
        .markdown-content {
            line-height: 1.7;
        }
        
        .markdown-content h1 {
            color: #e94560;
            font-size: 28px;
            margin-bottom: 10px;
            border-bottom: 2px solid rgba(233, 69, 96, 0.3);
            padding-bottom: 10px;
        }
        
        .markdown-content h2 {
            color: #ff6b6b;
            font-size: 22px;
            margin: 30px 0 15px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
        }
        
        .markdown-content h3 {
            color: #ffa500;
            font-size: 18px;
            margin: 20px 0 10px 0;
        }
        
        .markdown-content blockquote {
            border-left: 4px solid #e94560;
            padding-left: 16px;
            margin: 16px 0;
            color: #aaa;
            font-style: italic;
        }
        
        .markdown-content hr {
            border: none;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin: 30px 0;
        }
        
        .markdown-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            font-size: 14px;
        }
        
        .markdown-content th {
            background: rgba(233, 69, 96, 0.2);
            color: #e94560;
            text-align: left;
            padding: 12px;
            border-bottom: 2px solid rgba(233, 69, 96, 0.3);
        }
        
        .markdown-content td {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            background: rgba(255,255,255,0.02);
        }
        
        .markdown-content tr:hover td {
            background: rgba(255,255,255,0.05);
        }
        
        .markdown-content code {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
        }
        
        .markdown-content ul, .markdown-content ol {
            margin: 12px 0;
            padding-left: 24px;
        }
        
        .markdown-content li {
            margin: 6px 0;
        }
        
        .markdown-content p {
            margin: 12px 0;
        }
        
        .markdown-content em {
            color: #888;
        }
        
        .loading {
            text-align: center;
            padding: 60px;
            color: #888;
        }
        
        .error {
            text-align: center;
            padding: 40px;
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 12px;
        }
        
        .refresh-btn {
            display: block;
            margin: 30px auto 0;
            padding: 12px 24px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #ccc;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .refresh-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .last-updated {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-top: 20px;
        }

        /* Capybara Game Styles */
        .game-container {
            position: relative;
            max-width: 800px;
            margin: 0 auto;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px 12px 0 0;
            font-size: 18px;
        }

        .game-score {
            color: #4ade80;
        }

        .game-high-score {
            color: #fbbf24;
        }

        #game-canvas {
            display: block;
            width: 100%;
            max-width: 800px;
            height: auto;
            background: linear-gradient(180deg, #0f766e 0%, #134e4a 50%, #1e3a5f 100%);
            border-radius: 0 0 12px 12px;
            cursor: pointer;
        }

        .game-instructions {
            text-align: center;
            margin-top: 15px;
            color: #888;
            font-size: 14px;
        }

        .game-instructions kbd {
            background: rgba(255,255,255,0.1);
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .game-overlay {
            position: absolute;
            top: 44px;
            left: 0;
            right: 0;
            bottom: 45px;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0 0 12px 12px;
        }

        .game-overlay.hidden {
            display: none;
        }

        .overlay-content {
            text-align: center;
            padding: 30px;
        }

        .overlay-title {
            font-size: 32px;
            margin-bottom: 8px;
            color: #4ade80;
        }

        .overlay-subtitle {
            font-size: 18px;
            color: #fbbf24;
            margin-bottom: 20px;
        }

        .overlay-text {
            color: #aaa;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .game-btn {
            padding: 14px 36px;
            font-size: 18px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .game-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(74, 222, 128, 0.4);
        }

        @media (max-width: 600px) {
            #game-canvas {
                height: 250px;
            }
            .overlay-title {
                font-size: 24px;
            }
            .game-header {
                font-size: 14px;
            }
        }

        /* ========================================
           WARM-UP CALCULATOR STYLES
           Mobile-first, Starting Strength themed
           ======================================== */

        .warmup-container {
            max-width: 500px;
            margin: 0 auto;
            padding: 0 10px;
        }

        .warmup-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .warmup-header h1 {
            font-size: 28px;
            font-weight: 800;
            color: #f97316;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .warmup-tagline {
            color: #64748b;
            font-size: 14px;
        }

        /* Target Weight Input */
        .warmup-input-section {
            background: rgba(30, 64, 175, 0.15);
            border: 2px solid rgba(30, 64, 175, 0.3);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .warmup-input-section label {
            display: block;
            font-size: 14px;
            color: #94a3b8;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .weight-input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .weight-adjust {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            border: 2px solid rgba(249, 115, 22, 0.5);
            background: rgba(249, 115, 22, 0.1);
            color: #f97316;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .weight-adjust:hover {
            background: rgba(249, 115, 22, 0.3);
            transform: scale(1.05);
        }

        .weight-adjust:active {
            transform: scale(0.95);
        }

        #target-weight {
            width: 120px;
            height: 56px;
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            -moz-appearance: textfield;
        }

        #target-weight::-webkit-outer-spin-button,
        #target-weight::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .weight-unit {
            font-size: 18px;
            color: #94a3b8;
            font-weight: 600;
        }

        .calculate-btn {
            width: 100%;
            padding: 16px 24px;
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(135deg, #f97316, #ea580c);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(249, 115, 22, 0.4);
        }

        .calculate-btn:active {
            transform: translateY(0);
        }

        /* Warm-Up Sets Display */
        .warmup-sets {
            margin-bottom: 20px;
        }

        .warmup-placeholder {
            text-align: center;
            padding: 40px 20px;
            color: #64748b;
        }

        .warmup-quote {
            font-style: italic;
            margin-top: 16px;
            font-size: 13px;
            color: #475569;
        }

        .warmup-set-card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            position: relative;
        }

        .warmup-set-card.work-set {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(22, 163, 74, 0.1));
            border-color: rgba(34, 197, 94, 0.3);
        }

        .set-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .set-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #94a3b8;
        }

        .set-weight {
            font-size: 28px;
            font-weight: 800;
            color: #fff;
        }

        .set-weight .unit {
            font-size: 16px;
            color: #94a3b8;
            font-weight: 600;
        }

        .set-percentage {
            font-size: 14px;
            color: #f97316;
            font-weight: 600;
        }

        /* Progress bar */
        .set-progress {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            margin: 12px 0;
            overflow: hidden;
        }

        .set-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1e40af);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .work-set .set-progress-fill {
            background: linear-gradient(90deg, #22c55e, #16a34a);
        }

        .set-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .set-reps {
            font-size: 18px;
            font-weight: 600;
            color: #e2e8f0;
        }

        .set-reps span {
            color: #94a3b8;
            font-weight: 400;
        }

        /* Plate changes */
        .plate-changes {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed rgba(255,255,255,0.1);
            font-size: 13px;
        }

        .plate-change {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .plate-change.add {
            color: #4ade80;
        }

        .plate-change.remove {
            color: #f87171;
        }

        .plate-change.none {
            color: #64748b;
            font-style: italic;
        }

        /* Plate Configuration */
        .plate-config-section {
            margin-top: 20px;
        }

        .config-toggle {
            width: 100%;
            padding: 14px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            color: #94a3b8;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .config-toggle:hover {
            background: rgba(255,255,255,0.1);
        }

        .toggle-arrow {
            transition: transform 0.2s;
        }

        .config-toggle.open .toggle-arrow {
            transform: rotate(180deg);
        }

        .plate-config {
            display: none;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
            border-top: none;
            border-radius: 0 0 12px 12px;
            padding: 16px;
        }

        .plate-config.open {
            display: block;
        }

        .plate-config h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #64748b;
            margin: 16px 0 12px 0;
        }

        .plate-config h3:first-child {
            margin-top: 0;
        }

        .plate-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
        }

        .plate-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 8px 12px;
        }

        .plate-label {
            font-size: 14px;
            color: #e2e8f0;
            font-weight: 600;
        }

        .plate-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .plate-adjust {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .plate-adjust:hover {
            background: rgba(255,255,255,0.2);
        }

        .plate-count {
            min-width: 20px;
            text-align: center;
            font-weight: 600;
            color: #f97316;
        }

        .bar-config {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }

        #bar-weight-display {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
        }

        .save-config-btn {
            width: 100%;
            margin-top: 16px;
            padding: 12px;
            background: rgba(30, 64, 175, 0.3);
            border: 1px solid rgba(30, 64, 175, 0.5);
            border-radius: 8px;
            color: #93c5fd;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-config-btn:hover {
            background: rgba(30, 64, 175, 0.5);
        }

        .save-config-btn.saved {
            background: rgba(34, 197, 94, 0.3);
            border-color: rgba(34, 197, 94, 0.5);
            color: #86efac;
        }

        /* Mobile optimizations */
        @media (max-width: 400px) {
            .warmup-header h1 {
                font-size: 24px;
            }

            #target-weight {
                width: 100px;
                font-size: 28px;
            }

            .set-weight {
                font-size: 24px;
            }
        }

        /* ========================================
           ROUTINES TIMER STYLES
           Morning & Evening countdown timers
           ======================================== */

        .routine-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 40px 20px;
            text-align: center;
            border-radius: 24px;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .routine-icon {
            font-size: 80px;
            margin-bottom: 10px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .routine-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .routine-timer {
            margin: 30px 0;
        }

        .routine-minutes {
            font-size: 140px;
            font-weight: 800;
            line-height: 1;
            display: block;
            text-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .routine-label {
            font-size: 32px;
            opacity: 0.9;
            margin-top: 10px;
            display: block;
        }

        .routine-target {
            font-size: 18px;
            opacity: 0.8;
            margin-top: 20px;
        }

        .routine-message {
            font-size: 24px;
            margin-top: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
        }

        /* Morning theme - urgency based colors */
        .routine-container.morning {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(22, 163, 74, 0.2) 100%);
            border: 2px solid rgba(34, 197, 94, 0.4);
        }
        .routine-container.morning .routine-minutes { color: #22c55e; }

        .routine-container.morning-aware {
            background: linear-gradient(135deg, rgba(234, 179, 8, 0.3) 0%, rgba(202, 138, 4, 0.2) 100%);
            border: 2px solid rgba(234, 179, 8, 0.4);
        }
        .routine-container.morning-aware .routine-minutes { color: #eab308; }

        .routine-container.morning-hurry {
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.3) 0%, rgba(234, 88, 12, 0.2) 100%);
            border: 2px solid rgba(249, 115, 22, 0.4);
        }
        .routine-container.morning-hurry .routine-minutes { color: #f97316; }

        .routine-container.morning-urgent {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.4) 0%, rgba(220, 38, 38, 0.3) 100%);
            border: 2px solid rgba(239, 68, 68, 0.5);
            animation: urgentPulse 0.5s ease-in-out infinite;
        }
        .routine-container.morning-urgent .routine-minutes { color: #ef4444; }

        @keyframes urgentPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(239, 68, 68, 0.3); }
            50% { transform: scale(1.02); box-shadow: 0 0 50px rgba(239, 68, 68, 0.5); }
        }

        /* Evening themes */
        .routine-container.dinner {
            background: linear-gradient(135deg, #f97316 0%, #fbbf24 100%);
            border: 2px solid rgba(251, 191, 36, 0.5);
        }
        .routine-container.dinner .routine-minutes { color: #fff; }
        .routine-container.dinner .routine-title { color: #fff; }

        .routine-container.shower {
            background: linear-gradient(135deg, #3b82f6 0%, #22d3d8 100%);
            border: 2px solid rgba(34, 211, 216, 0.5);
        }
        .routine-container.shower .routine-minutes { color: #fff; }
        .routine-container.shower .routine-title { color: #fff; }

        .routine-container.bed {
            background: linear-gradient(135deg, #1e1b4b 0%, #8b5cf6 50%, #4c1d95 100%);
            border: 2px solid rgba(139, 92, 246, 0.5);
            position: relative;
        }
        .routine-container.bed .routine-minutes { color: #c4b5fd; }
        .routine-container.bed .routine-title { color: #e9d5ff; }

        /* Stars animation for bedtime */
        .routine-container.bed::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(2px 2px at 20px 30px, white, transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
                radial-gradient(1px 1px at 90px 40px, white, transparent),
                radial-gradient(2px 2px at 130px 80px, rgba(255,255,255,0.6), transparent),
                radial-gradient(1px 1px at 160px 30px, white, transparent),
                radial-gradient(2px 2px at 200px 60px, rgba(255,255,255,0.7), transparent),
                radial-gradient(1px 1px at 250px 20px, white, transparent),
                radial-gradient(2px 2px at 300px 50px, rgba(255,255,255,0.8), transparent),
                radial-gradient(1px 1px at 350px 70px, white, transparent),
                radial-gradient(2px 2px at 400px 30px, rgba(255,255,255,0.6), transparent);
            animation: twinkle 4s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Off-hours relaxed state */
        .routine-container.off-hours {
            background: linear-gradient(135deg, rgba(100, 116, 139, 0.2) 0%, rgba(71, 85, 105, 0.15) 100%);
            border: 2px solid rgba(100, 116, 139, 0.3);
        }
        .routine-container.off-hours .routine-icon { animation: none; }
        .routine-container.off-hours .routine-minutes { color: #94a3b8; font-size: 60px; }
        .routine-container.off-hours .routine-label { display: none; }

        /* Pulse animations for active timers */
        .routine-container.morning .routine-icon,
        .routine-container.dinner .routine-icon,
        .routine-container.shower .routine-icon,
        .routine-container.bed .routine-icon {
            animation: float 3s ease-in-out infinite;
        }

        .routine-container.morning-hurry .routine-icon {
            animation: bounce 0.6s ease-in-out infinite;
        }

        .routine-container.morning-urgent .routine-icon {
            animation: shake 0.3s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Chime notification flash - loops 5 times for ~3 seconds total */
        .routine-container.chime-flash {
            animation: chimeFlash 0.6s ease-in-out 5;
        }

        @keyframes chimeFlash {
            0%, 100% { filter: brightness(1); transform: scale(1); }
            50% { filter: brightness(1.4); transform: scale(1.03); }
        }

        /* Responsive */
        @media (max-width: 600px) {
            .routine-container {
                padding: 30px 15px;
                margin: 0 10px;
            }
            .routine-icon { font-size: 60px; }
            .routine-title { font-size: 22px; }
            .routine-minutes { font-size: 100px; }
            .routine-label { font-size: 24px; }
            .routine-message { font-size: 18px; padding: 15px; }
        }

        @media (max-width: 380px) {
            .routine-minutes { font-size: 80px; }
            .routine-label { font-size: 20px; }
        }
    </style>
</head>
<body>
    <nav class="tabs">
        <button class="tab active" data-page="grandma">üëµ Grandma Countdown</button>
        <button class="tab" data-page="routines">‚è∞ Routines</button>
        <button class="tab" data-page="todos">üìã TODOs</button>
        <button class="tab" data-page="game">üéÆ Capybara Game</button>
        <button class="tab" data-page="warmup">üèãÔ∏è Warm-Up</button>
    </nav>

    <div class="content">
        <!-- Grandma Countdown Page -->
        <div id="grandma" class="page active">
            <h2 class="countdown-page-title">Grandmas are coming!</h2>
            <div class="grandmas-container">
                <!-- Grandma Ayelet -->
                <div class="countdown-card ayelet">
                    <div class="countdown-emoji">üëµ</div>
                    <div class="countdown-title">◊°◊ë◊™◊ê ◊ê◊ô◊ú◊™ ◊û◊í◊ô◊¢◊î!</div>
                    <div class="countdown-subtitle">Grandma Ayelet is coming!</div>
                    <div class="countdown-number" id="days-ayelet">--</div>
                    <div class="countdown-label">days to go</div>
                    <div class="countdown-date">January 28, 2026</div>
                </div>

                <!-- Grandma Orly -->
                <div class="countdown-card orly">
                    <div class="countdown-emoji">üëµ</div>
                    <div class="countdown-title">◊°◊ë◊™◊ê ◊ê◊ï◊®◊ú◊ô ◊û◊í◊ô◊¢◊î!</div>
                    <div class="countdown-subtitle">Grandma Orly is coming!</div>
                    <div class="countdown-number" id="days-orly">--</div>
                    <div class="countdown-label">days to go</div>
                    <div class="countdown-date">April 16, 2026</div>
                </div>
            </div>
        </div>

        <!-- Routines Timer Page -->
        <div id="routines" class="page">
            <div class="routine-container" id="routine-container">
                <div class="routine-icon" id="routine-icon">‚è∞</div>
                <h2 class="routine-title" id="routine-title">Loading...</h2>
                <div class="routine-timer">
                    <span class="routine-minutes" id="routine-minutes">--</span>
                    <span class="routine-label" id="routine-label">minutes</span>
                </div>
                <div class="routine-target" id="routine-target"></div>
                <div class="routine-message" id="routine-message" style="display: none;"></div>
            </div>
        </div>

        <!-- TODOs Page (dynamically loaded) -->
        <div id="todos" class="page">
            <div id="todos-content" class="loading">Loading tasks...</div>
            <button class="refresh-btn" onclick="loadTasks()">üîÑ Refresh</button>
            <div class="last-updated" id="last-updated"></div>
        </div>

        <!-- Capybara Game Page -->
        <div id="game" class="page">
            <div class="game-container">
                <div class="game-header">
                    <div class="game-score">Score: <span id="score">0</span></div>
                    <div class="game-high-score">Best: <span id="high-score">0</span></div>
                </div>
                <canvas id="game-canvas" width="800" height="400"></canvas>
                <div class="game-instructions">
                    Press <kbd>SPACE</kbd> or <kbd>Click</kbd> to jump!
                </div>
                <div id="game-overlay" class="game-overlay">
                    <div class="overlay-content">
                        <div class="overlay-title">üèä Capybara River Run üå¥</div>
                        <div class="overlay-subtitle">Amazon Adventure!</div>
                        <div class="overlay-text" id="overlay-text">Help the capybara swim through the Amazon river!<br>Avoid dangerous creatures!</div>
                        <button class="game-btn" id="start-btn">Start Game</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Warm-Up Calculator Page -->
        <div id="warmup" class="page">
            <div class="warmup-container">
                <div class="warmup-header">
                    <h1>üèãÔ∏è Warm-Up Calculator</h1>
                    <p class="warmup-tagline">Get strong, stay safe!</p>
                </div>

                <!-- Target Weight Input -->
                <div class="warmup-input-section">
                    <label for="target-weight">Target Work Weight</label>
                    <div class="weight-input-group">
                        <button class="weight-adjust" id="weight-down">‚àí</button>
                        <input type="number" id="target-weight" value="135" min="35" step="5">
                        <button class="weight-adjust" id="weight-up">+</button>
                        <span class="weight-unit">lbs</span>
                    </div>
                    <button class="calculate-btn" id="calculate-warmup">Calculate Warm-Up</button>
                </div>

                <!-- Warm-Up Sets Display -->
                <div class="warmup-sets" id="warmup-sets">
                    <div class="warmup-placeholder">
                        <p>Enter your target weight and hit calculate!</p>
                        <p class="warmup-quote">"The only bad workout is the one that didn't happen."</p>
                    </div>
                </div>

                <!-- Plate Configuration -->
                <div class="plate-config-section">
                    <button class="config-toggle" id="config-toggle">
                        ‚öôÔ∏è My Plates <span class="toggle-arrow">‚ñº</span>
                    </button>
                    <div class="plate-config" id="plate-config">
                        <h3>Standard Plates (per side)</h3>
                        <div class="plate-grid" id="standard-plates">
                            <!-- Generated by JS -->
                        </div>
                        <h3>Micro Plates (per side)</h3>
                        <div class="plate-grid" id="micro-plates">
                            <!-- Generated by JS -->
                        </div>
                        <h3>Bar Weight</h3>
                        <div class="bar-config">
                            <button class="plate-adjust" data-bar="-5">‚àí</button>
                            <span id="bar-weight-display">35</span>
                            <span class="weight-unit">lbs</span>
                            <button class="plate-adjust" data-bar="+5">+</button>
                        </div>
                        <button class="save-config-btn" id="save-config">Save Configuration</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Tab switching
        function switchToTab(pageName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));

            const tab = document.querySelector(`.tab[data-page="${pageName}"]`);
            const page = document.getElementById(pageName);

            if (tab && page) {
                tab.classList.add('active');
                page.classList.add('active');
                localStorage.setItem('lastTab', pageName);

                // Load tasks when switching to TODOs tab
                if (pageName === 'todos') {
                    loadTasks();
                }
            }
        }

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => switchToTab(tab.dataset.page));
        });

        // Restore last visited tab
        const lastTab = localStorage.getItem('lastTab');
        if (lastTab && document.getElementById(lastTab)) {
            switchToTab(lastTab);
        }

        // Countdown calculator
        function updateCountdown() {
            const now = new Date();

            // Grandma Ayelet - January 28, 2026
            const ayeletDate = new Date('2026-01-28T00:00:00');
            const ayeletDiff = ayeletDate - now;
            const ayeletDays = Math.ceil(ayeletDiff / (1000 * 60 * 60 * 24));
            document.getElementById('days-ayelet').textContent = ayeletDays > 0 ? ayeletDays : "She's here!";

            // Grandma Orly - April 16, 2026
            const orlyDate = new Date('2026-04-16T00:00:00');
            const orlyDiff = orlyDate - now;
            const orlyDays = Math.ceil(orlyDiff / (1000 * 60 * 60 * 24));
            document.getElementById('days-orly').textContent = orlyDays > 0 ? orlyDays : "She's here!";
        }

        updateCountdown();
        setInterval(updateCountdown, 60000);

        // Load markdown tasks
        async function loadTasks() {
            const container = document.getElementById('todos-content');
            const lastUpdated = document.getElementById('last-updated');

            try {
                // Add cache-busting to always get fresh content
                const response = await fetch('tasks.md?t=' + Date.now());
                if (!response.ok) throw new Error('Failed to load tasks');

                const markdown = await response.text();
                container.innerHTML = '<div class="markdown-content">' + marked.parse(markdown) + '</div>';
                lastUpdated.textContent = 'Loaded: ' + new Date().toLocaleString();
            } catch (err) {
                container.innerHTML = '<div class="error">‚ùå Could not load tasks: ' + err.message + '</div>';
            }
        }

        // ========================================
        // CAPYBARA AMAZON RIVER GAME
        // ========================================
        const Game = {
            canvas: null,
            ctx: null,
            audioCtx: null,
            running: false,
            gameOver: false,
            score: 0,
            highScore: parseInt(localStorage.getItem('capybaraHighScore')) || 0,
            speed: 5,
            frameCount: 0,

            // Audio functions
            initAudio() {
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                // iOS Safari requires resume after user gesture
                if (this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }
            },

            playSound(type) {
                if (!this.audioCtx) return;
                // Ensure audio context is running (iOS fix)
                if (this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }
                const ctx = this.audioCtx;
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);

                if (type === 'jump') {
                    oscillator.frequency.setValueAtTime(300, ctx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.1);
                } else if (type === 'gameOver') {
                    oscillator.frequency.setValueAtTime(400, ctx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.4);
                    gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.4);
                } else if (type === 'milestone') {
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(523, ctx.currentTime);
                    oscillator.frequency.setValueAtTime(659, ctx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(784, ctx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.12, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.3);
                }
            },

            // Capybara player
            capybara: {
                x: 80,
                y: 280,
                width: 50,
                height: 40,
                velocityY: 0,
                jumping: false,
                groundY: 280
            },

            // Game objects
            obstacles: [],
            backgroundAnimals: [],
            bubbles: [],
            lilyPads: [],

            // Amazon animals
            dangerousAnimals: [
                { emoji: 'üêä', name: 'Caiman', width: 60, height: 35 },
                { emoji: 'üêç', name: 'Anaconda', width: 55, height: 30 },
                { emoji: 'ü¶à', name: 'Piranha', width: 40, height: 30 },
                { emoji: '‚ö°', name: 'Electric Eel', width: 50, height: 25 }
            ],

            friendlyAnimals: [
                { emoji: 'üê¨', name: 'Pink Dolphin' },
                { emoji: 'üê¢', name: 'River Turtle' },
                { emoji: 'üêü', name: 'Arapaima' },
                { emoji: 'ü¶ú', name: 'Macaw' },
                { emoji: 'ü¶©', name: 'Flamingo' },
                { emoji: 'üê∏', name: 'Poison Frog' },
                { emoji: 'ü¶é', name: 'Iguana' },
                { emoji: 'ü¶¶', name: 'Giant Otter' }
            ],

            init() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');

                // Set up high score display
                document.getElementById('high-score').textContent = this.highScore;

                // Event listeners
                document.getElementById('start-btn').addEventListener('click', () => this.start());
                this.canvas.addEventListener('click', () => this.handleInput());
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && document.getElementById('game').classList.contains('active')) {
                        e.preventDefault();
                        this.handleInput();
                    }
                });
            },

            handleInput() {
                if (!this.running && this.gameOver) {
                    this.start();
                } else if (this.running) {
                    this.jump();
                }
            },

            start() {
                if (!this.audioCtx) this.initAudio();
                this.running = true;
                this.gameOver = false;
                this.score = 0;
                this.speed = 5;
                this.frameCount = 0;
                this.capybara.y = this.capybara.groundY;
                this.capybara.velocityY = 0;
                this.capybara.jumping = false;
                this.obstacles = [];
                this.backgroundAnimals = [];
                this.bubbles = [];
                this.lilyPads = [];

                document.getElementById('score').textContent = '0';
                document.getElementById('game-overlay').classList.add('hidden');

                // Spawn initial decorations
                this.spawnLilyPads();
                this.spawnBackgroundAnimal();

                this.gameLoop();
            },

            jump() {
                if (!this.capybara.jumping) {
                    this.capybara.velocityY = -14;
                    this.capybara.jumping = true;
                    this.playSound('jump');
                }
            },

            spawnObstacle() {
                const animal = this.dangerousAnimals[Math.floor(Math.random() * this.dangerousAnimals.length)];
                this.obstacles.push({
                    x: this.canvas.width + 50,
                    y: this.capybara.groundY + (this.capybara.height - animal.height),
                    width: animal.width,
                    height: animal.height,
                    emoji: animal.emoji,
                    name: animal.name
                });
            },

            spawnBackgroundAnimal() {
                const animal = this.friendlyAnimals[Math.floor(Math.random() * this.friendlyAnimals.length)];
                const isFlying = animal.name === 'Macaw' || animal.name === 'Flamingo';
                this.backgroundAnimals.push({
                    x: this.canvas.width + 30,
                    y: isFlying ? 30 + Math.random() * 60 : 200 + Math.random() * 100,
                    emoji: animal.emoji,
                    speed: 1 + Math.random() * 2,
                    isFlying
                });
            },

            spawnLilyPads() {
                for (let i = 0; i < 5; i++) {
                    this.lilyPads.push({
                        x: Math.random() * this.canvas.width,
                        y: 330 + Math.random() * 50,
                        size: 20 + Math.random() * 15
                    });
                }
            },

            spawnBubble() {
                this.bubbles.push({
                    x: Math.random() * this.canvas.width,
                    y: this.canvas.height,
                    size: 3 + Math.random() * 5,
                    speed: 1 + Math.random() * 2
                });
            },

            update() {
                this.frameCount++;

                // Gravity
                this.capybara.velocityY += 0.7;
                this.capybara.y += this.capybara.velocityY;

                // Ground collision
                if (this.capybara.y >= this.capybara.groundY) {
                    this.capybara.y = this.capybara.groundY;
                    this.capybara.velocityY = 0;
                    this.capybara.jumping = false;
                }

                // Spawn obstacles
                if (this.frameCount % Math.max(60, 120 - Math.floor(this.score / 10)) === 0) {
                    this.spawnObstacle();
                }

                // Spawn background animals
                if (this.frameCount % 150 === 0) {
                    this.spawnBackgroundAnimal();
                }

                // Spawn bubbles
                if (this.frameCount % 30 === 0) {
                    this.spawnBubble();
                }

                // Update obstacles
                this.obstacles.forEach((obs, i) => {
                    obs.x -= this.speed;
                    if (obs.x + obs.width < 0) {
                        this.obstacles.splice(i, 1);
                    }
                });

                // Update background animals
                this.backgroundAnimals.forEach((animal, i) => {
                    animal.x -= animal.speed;
                    if (animal.x < -50) {
                        this.backgroundAnimals.splice(i, 1);
                    }
                });

                // Update bubbles
                this.bubbles.forEach((bubble, i) => {
                    bubble.y -= bubble.speed;
                    bubble.x += Math.sin(this.frameCount * 0.1) * 0.3;
                    if (bubble.y < 0) {
                        this.bubbles.splice(i, 1);
                    }
                });

                // Update lily pads
                this.lilyPads.forEach(pad => {
                    pad.x -= this.speed * 0.3;
                    if (pad.x < -30) {
                        pad.x = this.canvas.width + 30;
                        pad.y = 330 + Math.random() * 50;
                    }
                });

                // Collision detection
                const capy = this.capybara;
                for (const obs of this.obstacles) {
                    if (
                        capy.x < obs.x + obs.width - 15 &&
                        capy.x + capy.width - 10 > obs.x &&
                        capy.y < obs.y + obs.height - 10 &&
                        capy.y + capy.height > obs.y + 5
                    ) {
                        this.endGame();
                        return;
                    }
                }

                // Update score
                this.score++;
                if (this.score % 10 === 0) {
                    document.getElementById('score').textContent = Math.floor(this.score / 10);
                }

                // Increase speed over time and play milestone sound
                if (this.score % 500 === 0 && this.score > 0) {
                    this.speed = Math.min(12, this.speed + 0.5);
                    this.playSound('milestone');
                }
            },

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw river gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#0f766e');
                gradient.addColorStop(0.4, '#134e4a');
                gradient.addColorStop(1, '#164e63');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw jungle silhouette at top
                ctx.fillStyle = '#052e16';
                for (let i = 0; i < this.canvas.width; i += 40) {
                    const height = 30 + Math.sin(i * 0.05) * 20;
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + 20, height);
                    ctx.lineTo(i + 40, 0);
                    ctx.fill();
                }

                // Draw bubbles
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.bubbles.forEach(bubble => {
                    ctx.beginPath();
                    ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw lily pads
                ctx.fillStyle = '#166534';
                this.lilyPads.forEach(pad => {
                    ctx.beginPath();
                    ctx.ellipse(pad.x, pad.y, pad.size, pad.size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Add flower
                    ctx.font = `${pad.size * 0.8}px Arial`;
                    ctx.fillText('ü™∑', pad.x - pad.size * 0.4, pad.y + pad.size * 0.3);
                });

                // Draw background animals
                ctx.font = '30px Arial';
                this.backgroundAnimals.forEach(animal => {
                    ctx.globalAlpha = 0.6;
                    ctx.fillText(animal.emoji, animal.x, animal.y);
                    ctx.globalAlpha = 1;
                });

                // Draw water surface line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 320);
                for (let i = 0; i < this.canvas.width; i += 20) {
                    ctx.lineTo(i, 320 + Math.sin((i + this.frameCount * 2) * 0.05) * 5);
                }
                ctx.stroke();

                // Draw ground/riverbed
                ctx.fillStyle = '#1e3a5f';
                ctx.fillRect(0, 350, this.canvas.width, 50);

                // Draw obstacles (dangerous animals)
                ctx.font = '40px Arial';
                this.obstacles.forEach(obs => {
                    ctx.fillText(obs.emoji, obs.x, obs.y + obs.height);
                });

                // Draw capybara
                this.drawCapybara();

                // Draw score in game
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`Score: ${Math.floor(this.score / 10)}`, 20, 30);
            },

            drawCapybara() {
                const ctx = this.ctx;
                const c = this.capybara;

                // Body
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(c.x + 25, c.y + 25, 25, 18, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#A0522D';
                ctx.beginPath();
                ctx.ellipse(c.x + 45, c.y + 15, 15, 12, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Ears
                ctx.fillStyle = '#6B3710';
                ctx.beginPath();
                ctx.ellipse(c.x + 38, c.y + 5, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(c.x + 48, c.y + 3, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eye
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(c.x + 50, c.y + 12, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(c.x + 51, c.y + 11, 1, 0, Math.PI * 2);
                ctx.fill();

                // Nose
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(c.x + 58, c.y + 18, 4, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs (if not jumping, show swimming motion)
                ctx.fillStyle = '#8B4513';
                if (this.capybara.jumping) {
                    // Tucked legs while jumping
                    ctx.beginPath();
                    ctx.ellipse(c.x + 15, c.y + 35, 6, 4, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(c.x + 35, c.y + 35, 6, 4, -0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Swimming legs
                    const legOffset = Math.sin(this.frameCount * 0.3) * 3;
                    ctx.beginPath();
                    ctx.ellipse(c.x + 15, c.y + 38 + legOffset, 7, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(c.x + 35, c.y + 38 - legOffset, 7, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Splash effect when moving
                if (!this.capybara.jumping) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.font = '12px Arial';
                    ctx.fillText('üí¶', c.x - 5, c.y + 30 + Math.sin(this.frameCount * 0.5) * 3);
                }
            },

            endGame() {
                this.running = false;
                this.gameOver = true;
                this.playSound('gameOver');

                // Update high score
                const finalScore = Math.floor(this.score / 10);
                if (finalScore > this.highScore) {
                    this.highScore = finalScore;
                    localStorage.setItem('capybaraHighScore', this.highScore);
                    document.getElementById('high-score').textContent = this.highScore;
                }

                // Show overlay
                document.getElementById('overlay-text').innerHTML =
                    `Game Over!<br>Score: ${finalScore}<br>Best: ${this.highScore}`;
                document.getElementById('start-btn').textContent = 'Play Again';
                document.getElementById('game-overlay').classList.remove('hidden');
            },

            gameLoop() {
                if (!this.running) return;

                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        };

        // Initialize game when DOM is ready
        Game.init();

        // ========================================
        // WARM-UP CALCULATOR
        // Starting Strength methodology
        // ========================================
        const WarmUp = {
            // Default gym configuration
            config: {
                barWeight: 35,
                plates: {
                    45: 2, 35: 0, 25: 2, 15: 2, 10: 4, 5: 2, 2.5: 2,
                    1: 2, 0.75: 2, 0.5: 2, 0.25: 2
                }
            },

            standardPlates: [45, 35, 25, 15, 10, 5, 2.5],
            microPlates: [1, 0.75, 0.5, 0.25],

            init() {
                this.loadConfig();
                this.renderPlateConfig();
                this.bindEvents();

                // Load last target weight
                const lastWeight = localStorage.getItem('lastTargetWeight');
                if (lastWeight) {
                    document.getElementById('target-weight').value = lastWeight;
                }
            },

            loadConfig() {
                const saved = localStorage.getItem('gymConfig');
                if (saved) {
                    this.config = JSON.parse(saved);
                }
                document.getElementById('bar-weight-display').textContent = this.config.barWeight;
            },

            saveConfig() {
                localStorage.setItem('gymConfig', JSON.stringify(this.config));
                const btn = document.getElementById('save-config');
                btn.textContent = 'Saved!';
                btn.classList.add('saved');
                setTimeout(() => {
                    btn.textContent = 'Save Configuration';
                    btn.classList.remove('saved');
                }, 2000);
            },

            renderPlateConfig() {
                const standardContainer = document.getElementById('standard-plates');
                const microContainer = document.getElementById('micro-plates');

                standardContainer.innerHTML = this.standardPlates.map(weight =>
                    this.createPlateRow(weight)
                ).join('');

                microContainer.innerHTML = this.microPlates.map(weight =>
                    this.createPlateRow(weight)
                ).join('');
            },

            createPlateRow(weight) {
                const count = this.config.plates[weight] || 0;
                return `
                    <div class="plate-row">
                        <span class="plate-label">${weight}</span>
                        <div class="plate-controls">
                            <button class="plate-adjust" data-plate="${weight}" data-action="dec">‚àí</button>
                            <span class="plate-count" id="plate-${weight}">${count}</span>
                            <button class="plate-adjust" data-plate="${weight}" data-action="inc">+</button>
                        </div>
                    </div>
                `;
            },

            bindEvents() {
                // Calculate button
                document.getElementById('calculate-warmup').addEventListener('click', () => this.calculate());

                // Weight adjustment buttons
                document.getElementById('weight-up').addEventListener('click', () => {
                    const input = document.getElementById('target-weight');
                    input.value = parseInt(input.value) + 5;
                });
                document.getElementById('weight-down').addEventListener('click', () => {
                    const input = document.getElementById('target-weight');
                    input.value = Math.max(this.config.barWeight, parseInt(input.value) - 5);
                });

                // Enter key to calculate
                document.getElementById('target-weight').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.calculate();
                });

                // Config toggle
                document.getElementById('config-toggle').addEventListener('click', () => {
                    document.getElementById('config-toggle').classList.toggle('open');
                    document.getElementById('plate-config').classList.toggle('open');
                });

                // Plate adjustments
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('plate-adjust')) {
                        const plate = parseFloat(e.target.dataset.plate);
                        const action = e.target.dataset.action;
                        const bar = e.target.dataset.bar;

                        if (bar) {
                            this.config.barWeight = Math.max(15, Math.min(55, this.config.barWeight + parseInt(bar)));
                            document.getElementById('bar-weight-display').textContent = this.config.barWeight;
                        } else if (plate) {
                            if (action === 'inc') {
                                this.config.plates[plate] = (this.config.plates[plate] || 0) + 1;
                            } else {
                                this.config.plates[plate] = Math.max(0, (this.config.plates[plate] || 0) - 1);
                            }
                            document.getElementById(`plate-${plate}`).textContent = this.config.plates[plate];
                        }
                    }
                });

                // Save config
                document.getElementById('save-config').addEventListener('click', () => this.saveConfig());
            },

            // Calculate plate combination for a given weight
            // useMicros: true for work sets, false for warm-ups
            calculatePlates(targetWeight, useMicros = true) {
                const perSide = (targetWeight - this.config.barWeight) / 2;
                if (perSide <= 0) return { plates: [], total: this.config.barWeight };

                // For warm-ups, only use standard plates; for work sets, use all
                const platesToUse = useMicros
                    ? [...this.standardPlates, ...this.microPlates]
                    : [...this.standardPlates];
                const allPlates = platesToUse.sort((a, b) => b - a);

                const result = [];
                let remaining = perSide;
                const available = { ...this.config.plates };

                for (const plate of allPlates) {
                    while (remaining >= plate && (available[plate] || 0) > 0) {
                        result.push(plate);
                        remaining -= plate;
                        available[plate]--;
                    }
                }

                const actualPerSide = result.reduce((a, b) => a + b, 0);
                return {
                    plates: result,
                    total: this.config.barWeight + actualPerSide * 2
                };
            },

            // Generate all subset combinations of work plates
            // Returns array of {plates: [...], weight: number}
            generatePlateSubsets(workPlates) {
                const bar = this.config.barWeight;
                const subsets = [{ plates: [], weight: bar }];

                // Generate power set
                for (const plate of workPlates) {
                    const newSubsets = subsets.map(s => ({
                        plates: [...s.plates, plate],
                        weight: s.weight + plate * 2
                    }));
                    subsets.push(...newSubsets);
                }

                // Remove duplicates and sort by weight
                const seen = new Set();
                return subsets
                    .filter(s => {
                        const key = s.weight;
                        if (seen.has(key)) return false;
                        seen.add(key);
                        return true;
                    })
                    .sort((a, b) => a.weight - b.weight);
            },

            // Find best subset weight for target percentage
            findBestSubset(subsets, targetWeight, actualWork, prevWeight) {
                let best = null;
                let bestDiff = Infinity;

                for (const subset of subsets) {
                    // Skip if too close to previous or work weight
                    if (subset.weight <= prevWeight + 5) continue;
                    if (subset.weight >= actualWork - 5) continue;

                    const diff = Math.abs(subset.weight - targetWeight);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        best = subset;
                    }
                }
                return best;
            },

            // Helper to add a warm-up set with proper reps
            addWarmupSet(warmupSets, weight, plates, actualWork) {
                const pct = Math.round((weight / actualWork) * 100);

                // Determine reps: 5, 3, or 1 only
                let reps;
                if (pct <= 55) reps = 5;
                else if (pct <= 75) reps = 3;
                else reps = 1;

                warmupSets.push({
                    weight: weight,
                    percentage: pct,
                    sets: 1,
                    reps: reps,
                    plates: plates
                });
            },

            // Calculate warm-up sets using subset-first approach (minimize plate removal)
            calculate() {
                const targetInput = document.getElementById('target-weight');
                const targetWeight = parseInt(targetInput.value);

                if (isNaN(targetWeight) || targetWeight < this.config.barWeight) {
                    alert(`Please enter a weight of at least ${this.config.barWeight} lbs (bar weight)`);
                    return;
                }

                localStorage.setItem('lastTargetWeight', targetWeight);

                // Calculate work set plates first (with micros)
                const workSet = this.calculatePlates(targetWeight, true);
                const actualWork = workSet.total;

                // Generate all possible subset weights from work plates (no plate removal needed)
                // Use only standard plates for warm-up subsets
                const workPlatesStandard = workSet.plates.filter(p => this.standardPlates.includes(p));
                const subsets = this.generatePlateSubsets(workPlatesStandard);

                const warmupSets = [];

                // Always start with empty bar
                warmupSets.push({
                    weight: this.config.barWeight,
                    percentage: Math.round((this.config.barWeight / actualWork) * 100),
                    sets: 2,
                    reps: 5,
                    plates: [],
                    isBar: true
                });

                // Warm-up constraints:
                // - 3-4 warm-up sets (including bar)
                // - Last warm-up must be 80-89% of target
                // - First jump (from bar) can be up to 40%, others max 25%
                // - Earlier jumps should be larger than later jumps
                const maxWarmups = 4;
                const minWarmups = 3;
                const minLastPct = 0.80;  // Last warm-up must be at least 80%
                const maxLastPct = 0.89;  // Last warm-up must be BELOW 90%
                const maxFirstJumpPct = 0.40;  // First jump (from bar) can be larger
                const maxJumpPct = 0.25;  // Max 25% jump for other sets

                // Target percentages: evenly spread up to ~85%
                const targetPercentages = [0.4, 0.55, 0.7, 0.85];

                // First pass: try subset-only (no plate removal)
                for (const pct of targetPercentages) {
                    if (warmupSets.length >= maxWarmups) break;

                    const targetWarmup = Math.round(actualWork * pct);
                    const subset = this.findBestSubset(subsets, targetWarmup, actualWork,
                        warmupSets[warmupSets.length - 1].weight);

                    // Only use if within 15% of target AND below 90% threshold
                    if (subset &&
                        Math.abs(subset.weight - targetWarmup) <= actualWork * 0.15 &&
                        subset.weight < actualWork * maxLastPct) {
                        this.addWarmupSet(warmupSets, subset.weight, subset.plates, actualWork);
                    }
                }

                // Second pass: fill with non-subset weights until we have 4
                const fillPercentages = [0.45, 0.55, 0.65, 0.75, 0.85];
                for (const pct of fillPercentages) {
                    if (warmupSets.length >= minWarmups) break;

                    const targetWarmup = Math.round(actualWork * pct);

                    // Skip if we already have something within 10% of this target
                    const exists = warmupSets.some(s =>
                        Math.abs(s.percentage - pct * 100) <= 10
                    );
                    if (exists) continue;

                    const plateResult = this.calculatePlates(targetWarmup, false);

                    // Must be below 90%, not too close to existing, and valid range
                    const tooClose = warmupSets.some(s =>
                        Math.abs(s.weight - plateResult.total) <= 10
                    );

                    if (!tooClose &&
                        plateResult.total > this.config.barWeight + 5 &&
                        plateResult.total < actualWork * maxLastPct) {
                        this.addWarmupSet(warmupSets, plateResult.total, plateResult.plates, actualWork);
                    }
                }

                // Sort warm-ups by weight
                const barSet = warmupSets.shift();
                warmupSets.sort((a, b) => a.weight - b.weight);
                warmupSets.unshift(barSet);

                // Third pass: check for large gaps and fill them
                let hasLargeGap = true;
                while (hasLargeGap && warmupSets.length < maxWarmups + 2) {
                    hasLargeGap = false;

                    for (let i = 0; i < warmupSets.length - 1; i++) {
                        const current = warmupSets[i];
                        const next = warmupSets[i + 1];
                        const gapPct = (next.weight - current.weight) / actualWork;
                        // First jump (from bar) can be larger
                        const maxAllowedGap = (i === 0) ? maxFirstJumpPct : maxJumpPct;

                        if (gapPct > maxAllowedGap) {
                            // Found a large gap, try to fill it
                            const midWeight = Math.round((current.weight + next.weight) / 2);
                            const plateResult = this.calculatePlates(midWeight, false);

                            if (plateResult.total > current.weight + 10 &&
                                plateResult.total < next.weight - 10 &&
                                plateResult.total < actualWork * maxLastPct) {
                                this.addWarmupSet(warmupSets, plateResult.total, plateResult.plates, actualWork);
                                hasLargeGap = true;

                                // Re-sort after adding
                                const bar = warmupSets.shift();
                                warmupSets.sort((a, b) => a.weight - b.weight);
                                warmupSets.unshift(bar);
                                break;
                            }
                        }
                    }
                }

                // Trim to max 4 warm-ups (keep bar + highest 3)
                while (warmupSets.length > maxWarmups) {
                    warmupSets.splice(1, 1);  // Remove lowest non-bar
                }

                // Ensure last warm-up is in 80%-90% range
                const lastNonBar = warmupSets.filter(s => !s.isBar).pop();
                if (lastNonBar) {
                    const lastPct = lastNonBar.weight / actualWork;

                    // If last warm-up is below 80%, add one in range (don't remove yet)
                    if (lastPct < minLastPct) {
                        for (const targetPct of [0.85, 0.82]) {
                            const targetWeight = Math.round(actualWork * targetPct);
                            const plateResult = this.calculatePlates(targetWeight, false);
                            const pct = plateResult.total / actualWork;

                            if (pct >= minLastPct && pct < maxLastPct &&
                                plateResult.total > lastNonBar.weight) {
                                // Add without removing - let gap detection and trim handle it
                                this.addWarmupSet(warmupSets, plateResult.total, plateResult.plates, actualWork);

                                // Re-sort
                                const bar = warmupSets.shift();
                                warmupSets.sort((a, b) => a.weight - b.weight);
                                warmupSets.unshift(bar);
                                break;
                            }
                        }
                    }
                }

                // Re-run gap detection after adding 80-90% warm-up
                hasLargeGap = true;
                while (hasLargeGap && warmupSets.length < maxWarmups + 2) {
                    hasLargeGap = false;
                    for (let i = 0; i < warmupSets.length - 1; i++) {
                        const current = warmupSets[i];
                        const next = warmupSets[i + 1];
                        const gapPct = (next.weight - current.weight) / actualWork;
                        const maxAllowedGap = (i === 0) ? maxFirstJumpPct : maxJumpPct;

                        if (gapPct > maxAllowedGap) {
                            const midWeight = Math.round((current.weight + next.weight) / 2);
                            const plateResult = this.calculatePlates(midWeight, false);

                            if (plateResult.total > current.weight + 10 &&
                                plateResult.total < next.weight - 10 &&
                                plateResult.total < actualWork * maxLastPct) {
                                this.addWarmupSet(warmupSets, plateResult.total, plateResult.plates, actualWork);
                                hasLargeGap = true;
                                const bar = warmupSets.shift();
                                warmupSets.sort((a, b) => a.weight - b.weight);
                                warmupSets.unshift(bar);
                                break;
                            }
                        }
                    }
                }

                // Trim to max 4 warm-ups (keep bar and highest, remove from middle)
                while (warmupSets.length > maxWarmups) {
                    // Find the warm-up whose removal causes least jump disruption
                    // Remove the one that creates the smallest resulting gap
                    let bestRemoveIdx = 1;
                    let smallestResultingJump = Infinity;

                    for (let i = 1; i < warmupSets.length - 1; i++) {
                        const before = warmupSets[i - 1].weight;
                        const after = warmupSets[i + 1].weight;
                        const resultingJump = after - before;
                        if (resultingJump < smallestResultingJump) {
                            smallestResultingJump = resultingJump;
                            bestRemoveIdx = i;
                        }
                    }
                    warmupSets.splice(bestRemoveIdx, 1);
                }

                // Ensure earlier jumps are larger than later jumps
                // Remove warm-ups that break this pattern (keep bar and last)
                let jumpsValid = false;
                while (!jumpsValid && warmupSets.length > minWarmups) {
                    jumpsValid = true;
                    const jumps = [];

                    // Calculate all jumps
                    for (let i = 0; i < warmupSets.length - 1; i++) {
                        jumps.push(warmupSets[i + 1].weight - warmupSets[i].weight);
                    }

                    // Check if jumps are decreasing (earlier >= later)
                    for (let i = 0; i < jumps.length - 1; i++) {
                        if (jumps[i] < jumps[i + 1]) {
                            // Later jump is larger than earlier jump
                            // Remove the START of the small jump to merge with previous jump
                            // e.g., [35,60,85,115] with jumps [25,25,30]:
                            //   jumps[1]=25 < jumps[2]=30, so i=1
                            //   Remove index i+1=2? No, that gives [35,60,115]=[25,55], worse!
                            //   Remove index i=1? Yes! That gives [35,85,115]=[50,30], valid!
                            let removeIdx = i;

                            // But don't remove bar (index 0) or last warm-up
                            if (removeIdx === 0) removeIdx = 1;
                            if (removeIdx >= warmupSets.length - 1) removeIdx = warmupSets.length - 2;

                            if (removeIdx > 0 && removeIdx < warmupSets.length - 1) {
                                warmupSets.splice(removeIdx, 1);
                                jumpsValid = false;
                                break;
                            }
                        }
                    }
                }

                // Force last warm-up to 1 rep
                if (warmupSets.length > 1) {
                    const lastWarmup = warmupSets[warmupSets.length - 1];
                    if (!lastWarmup.isBar) {
                        lastWarmup.reps = 1;
                    }
                }

                // Add work set
                warmupSets.push({
                    weight: actualWork,
                    percentage: 100,
                    sets: 3,
                    reps: 5,
                    plates: workSet.plates,
                    isWork: true
                });

                this.renderSets(warmupSets);
            },

            // Calculate plate changes between sets
            getPlateChanges(prevPlates, currentPlates) {
                const prevCount = {};
                const currCount = {};

                prevPlates.forEach(p => prevCount[p] = (prevCount[p] || 0) + 1);
                currentPlates.forEach(p => currCount[p] = (currCount[p] || 0) + 1);

                const allPlates = [...new Set([...prevPlates, ...currentPlates])].sort((a, b) => b - a);
                const add = [];
                const remove = [];

                for (const plate of allPlates) {
                    const diff = (currCount[plate] || 0) - (prevCount[plate] || 0);
                    if (diff > 0) {
                        for (let i = 0; i < diff; i++) add.push(plate);
                    } else if (diff < 0) {
                        for (let i = 0; i < -diff; i++) remove.push(plate);
                    }
                }

                return { add, remove };
            },

            renderSets(sets) {
                const container = document.getElementById('warmup-sets');
                let html = '';

                for (let i = 0; i < sets.length; i++) {
                    const set = sets[i];
                    const prevPlates = i > 0 ? sets[i - 1].plates : [];
                    const changes = this.getPlateChanges(prevPlates, set.plates);

                    const label = set.isWork ? 'WORK SET' : set.isBar ? 'WARM-UP 1' : `WARM-UP ${i + 1}`;
                    const cardClass = set.isWork ? 'warmup-set-card work-set' : 'warmup-set-card';

                    html += `
                        <div class="${cardClass}">
                            <div class="set-header">
                                <span class="set-label">${label}</span>
                                <span class="set-percentage">${set.percentage}%</span>
                            </div>
                            <div class="set-weight">${set.weight} <span class="unit">lbs</span></div>
                            <div class="set-progress">
                                <div class="set-progress-fill" style="width: ${set.percentage}%"></div>
                            </div>
                            <div class="set-details">
                                <span class="set-reps">${set.sets} √ó ${set.reps} <span>reps</span></span>
                            </div>
                            ${this.renderPlateChanges(set, changes, i === 0)}
                        </div>
                    `;
                }

                container.innerHTML = html;
            },

            renderPlateChanges(set, changes, isFirst) {
                if (isFirst) {
                    return `
                        <div class="plate-changes">
                            <div class="plate-change none">Empty bar</div>
                        </div>
                    `;
                }

                let html = '<div class="plate-changes">';

                if (changes.add.length > 0) {
                    const grouped = this.groupPlates(changes.add);
                    html += `<div class="plate-change add">‚ûï Add: ${grouped} each side</div>`;
                }

                if (changes.remove.length > 0) {
                    const grouped = this.groupPlates(changes.remove);
                    html += `<div class="plate-change remove">‚ûñ Remove: ${grouped} each side</div>`;
                }

                if (changes.add.length === 0 && changes.remove.length === 0) {
                    html += `<div class="plate-change none">No plate changes</div>`;
                }

                html += '</div>';
                return html;
            },

            groupPlates(plates) {
                const counts = {};
                plates.forEach(p => counts[p] = (counts[p] || 0) + 1);
                return Object.entries(counts)
                    .sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]))
                    .map(([plate, count]) => count > 1 ? `${count}√ó${plate}` : plate)
                    .join(' + ');
            },

            // Test function to verify all rules
            runTests() {
                const testWeights = [95, 115, 135, 155, 185, 205, 225, 275, 315];
                const results = [];

                console.log('=== WARM-UP CALCULATOR TESTS ===\n');

                for (const target of testWeights) {
                    const workSet = this.calculatePlates(target, true);
                    const actualWork = workSet.total;
                    const bar = this.config.barWeight;

                    // Simulate calculation (simplified)
                    const workPlatesStandard = workSet.plates.filter(p => this.standardPlates.includes(p));
                    const subsets = this.generatePlateSubsets(workPlatesStandard);

                    // Run the same algorithm as calculate()
                    const warmupSets = [{ weight: bar, isBar: true }];
                    const maxWarmups = 4, minWarmups = 3;
                    const minLastPct = 0.80, maxLastPct = 0.89;
                    const maxFirstJumpPct = 0.40, maxJumpPct = 0.25;
                    const targetPercentages = [0.4, 0.55, 0.7, 0.85];

                    // First pass
                    for (const pct of targetPercentages) {
                        if (warmupSets.length >= maxWarmups) break;
                        const targetWarmup = Math.round(actualWork * pct);
                        const subset = this.findBestSubset(subsets, targetWarmup, actualWork, warmupSets[warmupSets.length - 1].weight);
                        if (subset && Math.abs(subset.weight - targetWarmup) <= actualWork * 0.15 && subset.weight < actualWork * maxLastPct) {
                            warmupSets.push({ weight: subset.weight, plates: subset.plates });
                        }
                    }

                    // Second pass
                    const fillPercentages = [0.45, 0.55, 0.65, 0.75, 0.85];
                    for (const pct of fillPercentages) {
                        if (warmupSets.length >= minWarmups) break;
                        const targetWarmup = Math.round(actualWork * pct);
                        const exists = warmupSets.some(s => Math.abs((s.weight / actualWork) * 100 - pct * 100) <= 10);
                        if (exists) continue;
                        const plateResult = this.calculatePlates(targetWarmup, false);
                        const tooClose = warmupSets.some(s => Math.abs(s.weight - plateResult.total) <= 10);
                        if (!tooClose && plateResult.total > bar + 5 && plateResult.total < actualWork * maxLastPct) {
                            warmupSets.push({ weight: plateResult.total, plates: plateResult.plates });
                        }
                    }

                    // Sort
                    const barSet = warmupSets.shift();
                    warmupSets.sort((a, b) => a.weight - b.weight);
                    warmupSets.unshift(barSet);

                    // Third pass - gap fill
                    let hasLargeGap = true;
                    while (hasLargeGap && warmupSets.length < maxWarmups + 2) {
                        hasLargeGap = false;
                        for (let i = 0; i < warmupSets.length - 1; i++) {
                            const gapPct = (warmupSets[i + 1].weight - warmupSets[i].weight) / actualWork;
                            const maxAllowedGap = (i === 0) ? maxFirstJumpPct : maxJumpPct;
                            if (gapPct > maxAllowedGap) {
                                const midWeight = Math.round((warmupSets[i].weight + warmupSets[i + 1].weight) / 2);
                                const plateResult = this.calculatePlates(midWeight, false);
                                if (plateResult.total > warmupSets[i].weight + 10 && plateResult.total < warmupSets[i + 1].weight - 10 && plateResult.total < actualWork * maxLastPct) {
                                    warmupSets.push({ weight: plateResult.total, plates: plateResult.plates });
                                    hasLargeGap = true;
                                    const b = warmupSets.shift();
                                    warmupSets.sort((a, b) => a.weight - b.weight);
                                    warmupSets.unshift(b);
                                    break;
                                }
                            }
                        }
                    }

                    // First trim
                    while (warmupSets.length > maxWarmups) warmupSets.splice(1, 1);

                    // Ensure last 80-90% (add without removing)
                    const lastNonBar = warmupSets.filter(s => !s.isBar).pop();
                    if (lastNonBar && lastNonBar.weight / actualWork < minLastPct) {
                        for (const targetPct of [0.85, 0.82]) {
                            const targetWeight = Math.round(actualWork * targetPct);
                            const plateResult = this.calculatePlates(targetWeight, false);
                            const pct = plateResult.total / actualWork;
                            if (pct >= minLastPct && pct < maxLastPct && plateResult.total > lastNonBar.weight) {
                                warmupSets.push({ weight: plateResult.total, plates: plateResult.plates });
                                const b = warmupSets.shift();
                                warmupSets.sort((a, b) => a.weight - b.weight);
                                warmupSets.unshift(b);
                                break;
                            }
                        }
                    }

                    // Re-run gap detection after 80-90%
                    hasLargeGap = true;
                    while (hasLargeGap && warmupSets.length < maxWarmups + 2) {
                        hasLargeGap = false;
                        for (let i = 0; i < warmupSets.length - 1; i++) {
                            const gapPct = (warmupSets[i + 1].weight - warmupSets[i].weight) / actualWork;
                            const maxAllowedGap = (i === 0) ? maxFirstJumpPct : maxJumpPct;
                            if (gapPct > maxAllowedGap) {
                                const midWeight = Math.round((warmupSets[i].weight + warmupSets[i + 1].weight) / 2);
                                const plateResult = this.calculatePlates(midWeight, false);
                                if (plateResult.total > warmupSets[i].weight + 10 && plateResult.total < warmupSets[i + 1].weight - 10 && plateResult.total < actualWork * maxLastPct) {
                                    warmupSets.push({ weight: plateResult.total, plates: plateResult.plates });
                                    hasLargeGap = true;
                                    const b = warmupSets.shift();
                                    warmupSets.sort((a, b) => a.weight - b.weight);
                                    warmupSets.unshift(b);
                                    break;
                                }
                            }
                        }
                    }

                    // Smart trim to max 4
                    while (warmupSets.length > maxWarmups) {
                        let bestIdx = 1, smallestGap = Infinity;
                        for (let i = 1; i < warmupSets.length - 1; i++) {
                            const gap = warmupSets[i + 1].weight - warmupSets[i - 1].weight;
                            if (gap < smallestGap) { smallestGap = gap; bestIdx = i; }
                        }
                        warmupSets.splice(bestIdx, 1);
                    }

                    // Ensure decreasing jumps (use removeIdx = i, not i+1)
                    let jumpsValid = false;
                    while (!jumpsValid && warmupSets.length > minWarmups) {
                        jumpsValid = true;
                        const jumps = [];
                        for (let i = 0; i < warmupSets.length - 1; i++) {
                            jumps.push(warmupSets[i + 1].weight - warmupSets[i].weight);
                        }
                        for (let i = 0; i < jumps.length - 1; i++) {
                            if (jumps[i] < jumps[i + 1]) {
                                let removeIdx = i;  // Changed from i+1
                                if (removeIdx === 0) removeIdx = 1;
                                if (removeIdx >= warmupSets.length - 1) removeIdx = warmupSets.length - 2;
                                if (removeIdx > 0 && removeIdx < warmupSets.length - 1) {
                                    warmupSets.splice(removeIdx, 1);
                                    jumpsValid = false;
                                    break;
                                }
                            }
                        }
                    }

                    // Verify rules
                    const weights = warmupSets.map(s => s.weight);
                    const jumps = [];
                    for (let i = 0; i < weights.length - 1; i++) {
                        jumps.push(weights[i + 1] - weights[i]);
                    }
                    const jumpPcts = jumps.map(j => (j / actualWork * 100).toFixed(1) + '%');
                    const lastWarmup = weights[weights.length - 1];
                    const lastPct = lastWarmup / actualWork;

                    const errors = [];
                    // Rule 1: 3-4 warm-ups
                    if (warmupSets.length < 3 || warmupSets.length > 4) errors.push(`Count: ${warmupSets.length} (expected 3-4)`);
                    // Rule 2: Last warm-up 80-89%
                    if (lastPct < 0.80 || lastPct >= 0.90) errors.push(`Last: ${(lastPct * 100).toFixed(1)}% (expected 80-89%)`);
                    // Rule 3: First jump ‚â§40%, others ‚â§25%
                    for (let i = 0; i < jumps.length; i++) {
                        const pct = jumps[i] / actualWork;
                        const max = i === 0 ? 0.40 : 0.25;
                        if (pct > max) errors.push(`Jump ${i + 1}: ${(pct * 100).toFixed(1)}% > ${max * 100}%`);
                    }
                    // Rule 4: Earlier jumps >= later jumps
                    for (let i = 0; i < jumps.length - 1; i++) {
                        if (jumps[i] < jumps[i + 1]) errors.push(`Jump ${i + 1} (${jumps[i]}) < Jump ${i + 2} (${jumps[i + 1]})`);
                    }

                    const status = errors.length === 0 ? '‚úì PASS' : '‚úó FAIL';
                    console.log(`Target: ${target} lbs (actual: ${actualWork} lbs)`);
                    console.log(`  Warm-ups: ${weights.join(' ‚Üí ')} ‚Üí ${actualWork} (work)`);
                    console.log(`  Jumps: ${jumpPcts.join(', ')}`);
                    console.log(`  Last warm-up: ${(lastPct * 100).toFixed(1)}%`);
                    console.log(`  ${status}${errors.length ? ': ' + errors.join(', ') : ''}`);
                    console.log('');

                    results.push({ target, actual: actualWork, pass: errors.length === 0, errors });
                }

                const passed = results.filter(r => r.pass).length;
                console.log(`=== RESULTS: ${passed}/${results.length} passed ===`);
                return results;
            }
        };

        // Initialize warm-up calculator
        WarmUp.init();

        // Run tests in console: WarmUp.runTests()

        // ========================================
        // ROUTINES TIMER
        // Morning & Evening countdown system
        // ========================================
        const RoutineTimer = {
            // Milestones configuration
            milestones: {
                morning: { hour: 7, minute: 20, icon: 'üè´', title: 'Time to Leave for School', target: 'Leave by 7:20 AM' },
                dinner:  { hour: 18, minute: 0, icon: 'üçΩÔ∏è', title: 'Dinner Time!', target: 'Dinner at 6:00 PM' },
                shower:  { hour: 18, minute: 45, icon: 'üöø', title: 'Shower Time!', target: 'Showers at 6:45 PM' },
                bed:     { hour: 19, minute: 30, icon: 'üåô', title: 'Bedtime!', target: 'Bed at 7:30 PM' }
            },

            // Time windows
            morningStart: 6,    // 6:00 AM
            morningEnd: 7,      // 7:20 AM (use milestone time)
            eveningStart: 17.5, // 5:30 PM
            eveningEnd: 19.5,   // 7:30 PM

            // State
            audioCtx: null,
            audioEnabled: false,
            lastChimeMinute: null,
            currentRoutine: null,

            init() {
                this.update();
                // Update every second
                setInterval(() => this.update(), 1000);

                // Enable audio on first user interaction
                const enableAudio = () => {
                    if (!this.audioEnabled) {
                        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        this.audioEnabled = true;
                        console.log('üîä Audio enabled!');
                        // Play a tiny test sound to confirm
                        this.playChime('dinner', false);
                    }
                };

                document.addEventListener('click', enableAudio, { once: true });
                document.addEventListener('touchstart', enableAudio, { once: true });
                document.addEventListener('keydown', enableAudio, { once: true });
            },

            initAudio() {
                // Audio is now initialized on user gesture in init()
                if (this.audioCtx && this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }
            },

            // Play themed chime based on current routine - plays 3 beeps
            playChime(routine, isUrgent = false) {
                if (!this.audioEnabled || !this.audioCtx) return;
                this.initAudio();
                const ctx = this.audioCtx;

                // Different sounds for different routines
                const sounds = {
                    morning: { freq: 880, type: 'sine', duration: 0.2 },      // Bright bell
                    dinner:  { freq: 660, type: 'triangle', duration: 0.25 }, // Warm dinner bell
                    shower:  { freq: 523, type: 'sine', duration: 0.2 },      // Water-like
                    bed:     { freq: 392, type: 'sine', duration: 0.3 }       // Soft, low
                };

                const sound = sounds[routine] || sounds.morning;
                const volume = isUrgent ? 0.25 : 0.15;
                const beepGap = 0.3; // Gap between beeps

                // Play 3 consecutive beeps
                for (let i = 0; i < 3; i++) {
                    const startTime = ctx.currentTime + (i * (sound.duration + beepGap));

                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);

                    oscillator.type = sound.type;

                    // For urgent, each beep is higher pitched
                    const freqMultiplier = isUrgent ? 1 + (i * 0.15) : 1;
                    oscillator.frequency.setValueAtTime(sound.freq * freqMultiplier, startTime);

                    gainNode.gain.setValueAtTime(volume, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + sound.duration);

                    oscillator.start(startTime);
                    oscillator.stop(startTime + sound.duration);
                }

                // Visual flash (animation loops 5x at 0.6s = 3 seconds)
                const container = document.getElementById('routine-container');
                container.classList.remove('chime-flash'); // Reset if already playing
                void container.offsetWidth; // Force reflow to restart animation
                container.classList.add('chime-flash');
                setTimeout(() => container.classList.remove('chime-flash'), 3000);
            },

            getCurrentRoutineType() {
                const now = new Date();
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const timeDecimal = hours + minutes / 60;

                // Morning: 6:00 AM - 7:20 AM
                if (timeDecimal >= this.morningStart && timeDecimal < 7 + 20/60) {
                    return 'morning';
                }

                // Evening: 5:30 PM - 7:30 PM
                if (timeDecimal >= this.eveningStart && timeDecimal < this.eveningEnd) {
                    // Determine which evening milestone
                    const dinnerTime = this.milestones.dinner.hour + this.milestones.dinner.minute/60;
                    const showerTime = this.milestones.shower.hour + this.milestones.shower.minute/60;
                    const bedTime = this.milestones.bed.hour + this.milestones.bed.minute/60;

                    if (timeDecimal < dinnerTime) return 'dinner';
                    if (timeDecimal < showerTime) return 'shower';
                    if (timeDecimal < bedTime) return 'bed';
                }

                return 'off-hours';
            },

            getMinutesRemaining(milestone) {
                const now = new Date();
                const target = new Date();
                target.setHours(milestone.hour, milestone.minute, 0, 0);

                // If target is in the past (shouldn't happen during active window), return 0
                if (target <= now) return 0;

                const diffMs = target - now;
                return Math.ceil(diffMs / (1000 * 60));
            },

            getMorningUrgencyClass(minutes) {
                if (minutes > 30) return 'morning';
                if (minutes > 15) return 'morning-aware';
                if (minutes > 5) return 'morning-hurry';
                return 'morning-urgent';
            },

            getOffHoursMessage() {
                const now = new Date();
                const hours = now.getHours();

                if (hours < this.morningStart) {
                    return { icon: 'üò¥', title: 'Still sleeping time...', message: 'Go back to sleep!' };
                }
                if (hours >= 7 && hours < 12) {
                    return { icon: 'üìö', title: 'Have a great day!', message: 'Learning time at school!' };
                }
                if (hours >= 12 && hours < this.eveningStart) {
                    return { icon: '‚òÄÔ∏è', title: 'Enjoy your day!', message: 'See you at dinner time!' };
                }
                // After 7:30 PM
                return { icon: 'üåü', title: 'Good night!', message: 'Sweet dreams!' };
            },

            update() {
                const routineType = this.getCurrentRoutineType();
                const container = document.getElementById('routine-container');
                const iconEl = document.getElementById('routine-icon');
                const titleEl = document.getElementById('routine-title');
                const minutesEl = document.getElementById('routine-minutes');
                const labelEl = document.getElementById('routine-label');
                const targetEl = document.getElementById('routine-target');
                const messageEl = document.getElementById('routine-message');

                // Remove all theme classes
                container.className = 'routine-container';

                if (routineType === 'off-hours') {
                    const offHours = this.getOffHoursMessage();
                    container.classList.add('off-hours');
                    iconEl.textContent = offHours.icon;
                    titleEl.textContent = offHours.title;
                    minutesEl.textContent = offHours.message;
                    labelEl.style.display = 'none';
                    targetEl.textContent = '';
                    messageEl.style.display = 'none';
                    this.lastChimeMinute = null;
                    return;
                }

                // Active routine
                const milestone = this.milestones[routineType];
                const minutes = this.getMinutesRemaining(milestone);

                // Apply theme class
                if (routineType === 'morning') {
                    container.classList.add(this.getMorningUrgencyClass(minutes));
                } else {
                    container.classList.add(routineType);
                }

                // Update display
                iconEl.textContent = milestone.icon;
                titleEl.textContent = milestone.title;
                minutesEl.textContent = minutes;
                labelEl.textContent = minutes === 1 ? 'minute' : 'minutes';
                labelEl.style.display = 'block';
                targetEl.textContent = milestone.target;

                // Show message at milestone time (0 minutes)
                if (minutes === 0) {
                    messageEl.textContent = routineType === 'morning' ? 'Time to go! üèÉ‚Äç‚ôÄÔ∏è' :
                                           routineType === 'dinner' ? 'Food is ready! üçΩÔ∏è' :
                                           routineType === 'shower' ? 'Get in the shower! üöø' :
                                           'Time for bed! üåô';
                    messageEl.style.display = 'block';
                } else {
                    messageEl.style.display = 'none';
                }

                // Check for 5-minute mark chime
                this.checkChime(routineType, minutes);
            },

            checkChime(routineType, minutes) {
                // Chime at 5-minute intervals
                const chimeMinutes = [60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10, 5, 0];

                if (chimeMinutes.includes(minutes) && this.lastChimeMinute !== minutes) {
                    this.lastChimeMinute = minutes;
                    // More urgent chime for lower minutes
                    const isUrgent = minutes <= 10;
                    this.playChime(routineType, isUrgent);
                }

                // Reset lastChimeMinute when routine changes
                if (this.currentRoutine !== routineType) {
                    this.currentRoutine = routineType;
                    this.lastChimeMinute = null;
                }
            }
        };

        // Initialize routines timer
        RoutineTimer.init();
    </script>
</body>
</html>
